<h1>Vulkan tutoriál: Informace o zařízení (4. díl)</h1>

<p>Každé zařízení ve Vulkan má hromadu vlastností, schopností, limitů,
dostupné paměti a dalších informací, které o zařízení můžeme zjistit
a které často potřebujeme než vytvoříme konkrétní logické zařízení.
Dnes si tedy ukážeme, jak na tyto informace, které jsou často důležité i při běhu aplikace.</p>

<p>Při startu aplikace potřebujeme často ověřit, zda je podporována požadovaná
verze Vulkan, požadovaný formát textur, zda je k dispozici geometry shader,
a kolik grafické paměti je k dispozici, atd. Podle těchto informací můžeme z více zařízení,
pokud jsou k dispozici, vybrat to, které více odpovídá našim požadavkům.</p>

<p>Pojďme tedy na věc. Můžeme si stáhnout <a href="">zdrojové kódy</a> a zkusit je zkompilovat.
Po jejich spuštění bychom měli vidět výstup podobný tomuto:</p>

<pre>
Vulkan instance version: 1.1.0
Physical devices:
   GeForce GTX 1050
      Vulkan version: 1.1.84
      MaxTextureSize: 32768
      Geometry shader: supported
      Memory heaps:
         0: 1958MiB
         1: 32168MiB
      Queue families:
         0: gct
         1: t
         2: c
      R8G8B8A8Unorm format support:
         Images with linear tiling: no
         Images with optimal tiling: yes
         Buffers: no
   Radeon(TM) RX 460 Graphics
      Vulkan version: 1.1.101
      MaxTextureSize: 16384
      Geometry shader: supported
      Memory heaps:
         0: 1792MiB
         1: 16084MiB
         2: 256MiB
      Queue families:
         0: gct
         1: ct
         2: t
      R8G8B8A8Unorm format support:
         Images with linear tiling: yes
         Images with optimal tiling: yes
         Buffers: no
</pre>

<p>V tomto výpise vidíme, že Vulkan verze instance je 1.1,
a pak vidíme dvě grafické karty v daném počítači, na kterém byla aplikace puštěna.
Podíváme-li se dále, může nás zmást, že i každá karta má svou verzi Vulkan.
A opravdu je tak. V minulém díle jsme hovořili o Vulkan loader a driverech zařízení (ICD,
Installable Client Driver). Verze instance je pak verzí Vulkan loader knihovny,
kdežto Vulkanní verze driveru je Vulkan verze daného ICD.
Pro více informací odkazuji do Vulkanní dokumentace.</p>

<p>Dále ve výpisu vidíme maximální velikost textury, zda je podporován geometry shader,
kolik máme hald paměti a jejich velikosti, kolik máme typů front a co umí (g - graphics
rendering, c - compute, t - transfer) a na závěr podpora různých formátů.
Nicméně, začněme náš výklad od kódu.</p>

<h3>Verze Vulkan instance</h3>

<pre>
// Vulkan version
auto vkEnumerateInstanceVersion=reinterpret_cast&lt;PFN_vkEnumerateInstanceVersion&gt;(
		vkGetInstanceProcAddr(nullptr,"vkEnumerateInstanceVersion"));
if(vkEnumerateInstanceVersion) {
	uint32_t version;
	vkEnumerateInstanceVersion(&amp;version);
	cout&lt;&lt;"Vulkan instance version: "&lt;&lt;VK_VERSION_MAJOR(version)&lt;&lt;"."&lt;&lt;VK_VERSION_MINOR(version)
			&lt;&lt;"."&lt;&lt;VK_VERSION_PATCH(version)&lt;&lt;endl;
} else
	cout&lt;&lt;"Vulkan version: 1.0"&lt;&lt;endl;
</pre>

<p>Pro zjištění Vulkan verze instance používáme funkci vkEnumerateInstanceVersion.
Tato funkce je přítomná až od Vulkan verze 1.1, proto ji nevoláme staticky,
neboť nemusí být přítomna. Místo toho si na ni vezmeme funkční pointer.
Je-li null, jedná se o verzi 1.0. Není-li null, zavoláme ji.
Vrácenou hodnotu v uint32_t pak dekódujeme za použití maker VK_VERSION_MAJOR
a jeho obdobami pro MINOR a PATCH komponenty.</p>

<p>Dovolím si zmínit jeden podstatný detail týkající se Vulkanní verze instance.
Když vytváříme instanci, zadáváme požadovanou verzi Vulkan, kterou bude
aplikace používat. Daný řádek jsem zvýraznil tučně v následujícím kódu:</p>

<pre>
// Vulkan instance
vk::UniqueInstance instance(
	vk::createInstanceUnique(
		vk::InstanceCreateInfo{
			vk::InstanceCreateFlags(),  // flags
			&(const vk::ApplicationInfo&)vk::ApplicationInfo{
				"04-deviceInfo",         // application name
				VK_MAKE_VERSION(0,0,0),  // application version
				nullptr,                 // engine name
				VK_MAKE_VERSION(0,0,0),  // engine version
				<b>VK_API_VERSION_1_0,      // api version</b>
			},
			0,nullptr,  // no layers
			0,nullptr,  // no extensions
		}));
</pre>

<p>Pokud zadáme verzi 1.0, nevzniká žádný problém. Pokud ale zadáme vyšší verzi,
mohou nastat dvě situace. Pokud Vulkan instance podporuje verzi 1.1 či jakoukoliv vyšší,
vše je vpohodě. Je pouze naší povinností nepoužívat funkcionalitu, která není podporována.
Pokud je ale verze Vulkan instance 1.0, dojde k chybě při vytváření instance.
Pro programátora může být tedy nezbytné testovat verzi Vulkan instance dříve než
požádá o vyšší verzi Vulkan API. Více informací k tomuto tématu je ve Vulkan dokumentaci
v části pojednávající o struktuře VkApplicationInfo, případně i v části věnované
funkci vkCreateInstance.</p>

<p>V tomto tutoriálu si dlouhou dobu vystačíme pouze s Vulkan 1.0 a použitím extensions.
Problém se nás tedy bezprostředně netýká. Pokud bychom ale chtěli využít funkcionalitu
Vulkan 1.1 či vyšší, jsme povinni o to požádat v proměnné vk::InstanceCreateInfo::apiVersion.</p>

<p>Další kód prochází jednotlivá fyzická zařízení.
Pro každé zařízení pak volá několik funkcí, které si nyní popíšeme.</p>

<h3>Device properties (vlastnosti zařízení)</h3>

<pre>
// device properties
vk::PhysicalDeviceProperties p=pd.getProperties();
cout&lt;&lt;"   "&lt;&lt;p.deviceName&lt;&lt;endl;

// device Vulkan version
cout&lt;&lt;"      Vulkan version: "&lt;&lt;VK_VERSION_MAJOR(p.apiVersion)&lt;&lt;"."&lt;&lt;VK_VERSION_MINOR(p.apiVersion)
		&lt;&lt;"."&lt;&lt;VK_VERSION_PATCH(p.apiVersion)&lt;&lt;endl;
</pre>

<p>Metoda getProperties nám pro dané fyzické zařízení vrátí strukturu
vk::PhysicalDeviceProperties. Podíváme-li se do dokumentace, tato struktura
nese množství zajímavých proměnných. Nám již notoricky známá je šestá položka
deviceName, kterou si vypisujeme na obrazovku jako název zařízení.</p>

<p>Další zajímavou položkou je apiVersion. Toto je verze Vulkan API, kterou
dané zařízení poskytuje. Na obrzovku si jej vypíšeme za použití stejných maker
jako u Vulkan verze instance.</p>

<p>Další proměnné jsou driverVersion, vendorId, deviceId, deviceType,
pipelineCacheUUID. V případě zájmu odkazuji na jejich význam do dokumentace.</p>

<h3>Device limits (limity zařízení)</h3>

<p>Základní limity zařízení jsou uloženy ve struktuře vk::PhysicalDeviceLimits,
která je součástí vk::PhysicalDeviceProperties. Velmi snadno si tedy
vypíšeme maximální rozlišení 2D textury.

<pre>
// device limits
cout&lt;&lt;"      MaxTextureSize: "&lt;&lt;p.limits.maxImageDimension2D&lt;&lt;endl;
</pre>

<p>Limitů je obrovské množství. Vulkan dokumentace nás na ně občas odkáže.
I my se některými z nich budeme zabývat, ale až je budeme potřebovat.</p>

<h3>Device features (funkcionality zařízení)</h3>

<p>Jsou určité funkcionality, které u daného zařízení mohou nebo nemusí být podporovány.
Například geometry shader nemusí být přítomen na určitém tabletu, mobilním zařízení
nebo Raspberry Pi. Soubor podporovaných funkcionalit Vulkan 1.0 zjistíme
zavolání metody getFeatures nad daným fyzickým zařízením.</p>

<pre>
// device features
vk::PhysicalDeviceFeatures f=pd.getFeatures();
cout&lt;&lt;"      Geometry shader: ";
if(f.geometryShader)
	cout&lt;&lt;"supported"&lt;&lt;endl;
else
	cout&lt;&lt;"not supported"&lt;&lt;endl;
</pre>

<p>Vrácená struktura vk::PhysicalDeviceFeatures obsahuje 55 booleanů indikujících,
co je podporováno a co ne. Mezi nimi je zmíněný geometry shader, dále třeba tesselační shader nebo
anizotropní filtrování, různé komprese textur, podpora výpočtů s dvounásobnou přesností (double precision)
a mnoho dalších, které opět najdeme ve Vulkan dokumentaci.</p>

<h3>Paměť</h3>

<p>Další informace, které můžeme získat o fyzickém zařízení se týkají paměti.
Ty získáme zavoláním metody getMemoryProperties:</p>

<pre>
// memory properties
vk::PhysicalDeviceMemoryProperties m=pd.getMemoryProperties();
cout&lt;&lt;"      Memory heaps:"&lt;&lt;endl;
for(uint32_t i=0,c=m.memoryHeapCount; i&lt;c; i++)
	cout&lt;&lt;"         "&lt;&lt;i&lt;&lt;": "&lt;&lt;m.memoryHeaps[i].size/1024/1024&lt;&lt;"MiB"&lt;&lt;endl;
</pre>

<p>Vrácená struktura vk::PhysicalDeviceMemoryProperties obsahuje informace o dostupných typech paměti
a o haldách, které jsou k dispozici. Začněme u hald, které si vypisujeme na obrazovku.
Haldy jsou často jedna, dvě nebo tři. Jedná je někdy například na některých integrovaných grafikách,
protože tam je pamět jediná a sdílená s procesorem. Dvě je velmi častý případ a řekl bych nejtypičtější -
jedna halda je lokální rychlá paměť na grafice a druhá halda je klasická paměť počítače nebo její část.
Tato paměť není pro grafický chip tak rychle přístupná, nicméně přístupná je.


